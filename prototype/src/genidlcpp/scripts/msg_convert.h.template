@###############################################
@#
@# Conversion functions between a ROS message
@# and DDS message
@#
@# EmPy template for <msg>_convert.h files
@#
@###############################################

#ifndef __@(spec.package)__@(spec.short_name)__convert__h__
#define __@(spec.package)__@(spec.short_name)__convert__h__

#include "@(spec.package)/@(spec.short_name).h"
#include "@(spec.package)/dds_impl/@(spec.short_name)_.h"
#include "@(spec.package)/dds_impl/@(spec.short_name)_Dcps_impl.h"

#include "genidlcpp/resolver.h"

namespace dds_impl
{

template <>
void convert_ros_message_to_dds<@(spec.package)::@(spec.short_name), @(spec.package)::dds_impl::@(spec.short_name)_>(const @(spec.package)::@(spec.short_name)& ros_message, @(spec.package)::dds_impl::@(spec.short_name)_& dds_message)
{
@[for field in spec.parsed_fields()]@
  // field.name @(field.name)
  // field.type @(field.type)
  // field.base_type @(field.base_type)
  // field.is_array @(field.is_array)
@[if field.array_len]@
  // field.array_len @(field.array_len)
@[else]@
  // field.array_len dynamic
@[end if]@
  // field.is_header @(field.is_header)
  // field.is_builtin @(field.is_builtin)
@[if field.is_array]@
  {
@[if field.array_len]@
    size_t size = @(field.array_len);
@[else]@
    size_t size = ros_message.@(field.name).size();
    dds_message.@(field.name)_.length(size);
@[end if]@
    for (size_t i = 0; i < size; i++) {
@[if field.base_type in ['duration', 'time']]@
      dds_message.@(field.name)_[i].sec = ros_message.@(field.name)[i].sec;
      dds_message.@(field.name)_[i].nanosec = ros_message.@(field.name)[i].nsec;
@[elif field.base_type == 'string']@
      dds_message.@(field.name)_[i] = ros_message.@(field.name)[i].c_str();
@[elif field.is_builtin]@
      dds_message.@(field.name)_[i] = ros_message.@(field.name)[i];
@[elif 'Dimension' not in field.type]@
      //convert_ros_message_to_dds(ros_message.@(field.name)[i], dds_message.@(field.name)_[i]);
@[end if]@
    }
  }
@[elif field.type in ['duration', 'time']]@
  dds_message.@(field.name)_.sec = ros_message.@(field.name).sec;
  dds_message.@(field.name)_.nanosec = ros_message.@(field.name).nsec;
@[elif field.type == 'string']@
  dds_message.@(field.name)_ = ros_message.@(field.name).c_str();
@[elif field.is_builtin]@
  dds_message.@(field.name)_ = ros_message.@(field.name);
@[else]@
  //convert_ros_message_to_dds(ros_message.@(field.name), dds_message.@(field.name)_);
@[end if]@

@[end for]@
}

template <>
void convert_dds_message_to_ros<@(spec.package)::dds_impl::@(spec.short_name)_, @(spec.package)::@(spec.short_name)>(const @(spec.package)::dds_impl::@(spec.short_name)_& dds_message, @(spec.package)::@(spec.short_name)& ros_message)
{
@[for field in spec.parsed_fields()]@
  // field.name @(field.name)
  // field.type @(field.type)
  // field.base_type @(field.base_type)
  // field.is_array @(field.is_array)
@[if field.array_len]@
  // field.array_len @(field.array_len)
@[else]@
  // field.array_len dynamic
@[end if]@
  // field.is_header @(field.is_header)
  // field.is_builtin @(field.is_builtin)
@[if field.is_array]@
  {
@[if field.array_len]@
    size_t size = @(field.array_len);
@[else]@
    size_t size = dds_message.@(field.name)_.length();
    ros_message.@(field.name).resize(size);
@[end if]@
    for (size_t i = 0; i < size; i++) {
@[if field.base_type in ['duration', 'time']]@
      ros_message.@(field.name)[i].sec = dds_message.@(field.name)_[i].sec;
      ros_message.@(field.name)[i].nsec = dds_message.@(field.name)_[i].nanosec;
@[elif field.is_builtin]@
      ros_message.@(field.name)[i] = dds_message.@(field.name)_[i];
@[elif 'Dimension' not in field.type]@
      //convert_dds_message_to_ros(dds_message.@(field.name)_[i], ros_message.@(field.name)[i]);
@[end if]@
    }
  }
@[elif field.type in ['duration', 'time']]@
  ros_message.@(field.name).sec = dds_message.@(field.name)_.sec;
  ros_message.@(field.name).nsec = dds_message.@(field.name)_.nanosec;
@[elif field.is_builtin]@
  ros_message.@(field.name) = dds_message.@(field.name)_;
@[else]@
  //convert_dds_message_to_ros(dds_message.@(field.name)_, ros_message.@(field.name));
@[end if]@

@[end for]@
}

template<>
struct DDSTypeResolver<@(spec.package)::@(spec.short_name)>
{
  typedef @(spec.package)::dds_impl::@(spec.short_name)_ DDSMsgType;
  typedef @(spec.package)::dds_impl::@(spec.short_name)__var DDSMsgType_var;
  typedef @(spec.package)::dds_impl::@(spec.short_name)_Seq DDSMsgSeqType;
  typedef @(spec.package)::dds_impl::@(spec.short_name)_Seq_var DDSMsgSeqType_var;
  typedef @(spec.package)::dds_impl::@(spec.short_name)_TypeSupport DDSMsgTypeSupportType;
  typedef @(spec.package)::dds_impl::@(spec.short_name)_TypeSupport_var DDSMsgTypeSupportType_var;
  typedef @(spec.package)::dds_impl::@(spec.short_name)_DataWriter DDSMsgDataWriterType;
  typedef @(spec.package)::dds_impl::@(spec.short_name)_DataWriter_var DDSMsgDataWriterType_var;
  typedef @(spec.package)::dds_impl::@(spec.short_name)_DataReader DDSMsgDataReaderType;
  typedef @(spec.package)::dds_impl::@(spec.short_name)_DataReader_var DDSMsgDataReaderType_var;
};

}; // namespace dds_impl

#endif
